# iOS Code Review Checklist

## Static Code Analyzer(Swiftlint)

- Make sure No compilation error or warning

## General

- Single Responsibility Principle (SRS)
  -  Do not place more than one responsibility into a single class or function, refactor into separate classes and functions **(Plain Objects).**
- Open Closed Principle
  -  While adding new functionality, existing code should not be modified. New functionality should be written in new classes and functions **(extensions)**.
- KISS(Keep it simple and stupid)
  - The KISS principle is descriptive to keep the code simple and clear, making it easy to understand. After all, programming languages are for humans to understand — computers can only understand 0 and 1 — so keep coding simple and straightforward. Keep your methods small. Each method should only solve one small problem, not many use cases. If you have a lot of conditions in the method, break these out into smaller methods. It will not only be easier to read and maintain, but it can help find bugs a lot faster
- Comments
  - If you need to add a comment to describe anything in your code then probably the code is ugly and not understandable so you need to revise naming and logic to keep it simple
- Magic #, avoid any magic number, define constants instead.Think first if this constant is specific for this view or it&#39;s a global setting that should be shared between views
- DRY(do not repeat yourself), we should avoid any code duplication
- Unused code
  - Always delete unused code also code that is generated by IDE. In code review when you see empty method, unused variable, outdated comments, imports hanging around your code, don&#39;t just leave it, it should be removed.
- Clarity is more important than brevity. Take more time when writing code to optimize for reading. Code is read much more often than written.
- Avoid Nested if
- Prefer switch over if-else
- Localization, do you have any unlocalized strings. All strings shall be localized.
- Third party dependency version, please make sure to add the dependency version

## Architecture

- Project architectural pattern,, make sure you follow the project's architectural pattern
- Responsibility, ask yourself if this code is the responsibility of the layer you added in or not eg.rounded corner, shadows are the view responsibility not the model or the business logic, but if it&#39;s for a cell shall the cell set it or the viewController ?!
- Naming convention, make sure you follow the project&#39;s naming convention
- Prefer dependency injection for dependencies.
- Prefer Composition over inheritance as Swift does not support multiple inheritance.
  - create Protocols and extend them using Protocol Extensions to provide default method implementations. This allows us to create much cleaner code, compared to what we could implement by relying solely on the Classical Inheritance pattern.  

## Performance

- Main thread, heavy operation shall not be done on main thread, main thread is designed mainly for UI operations
- Debug view hierarchy
  - To determine if you have any UI issue or overlapping views, please debug view hierarchy
- Debug memory graph
  - To determine if you have any strong reference cycle, please debug the memory graph and make sure we don't have any memory leak
- Remove observers/invalidate timer on view dismissing


## UI

- Different screen sizes, does the design fit on all screen sizes.
- Constraints logic, does the constraints logic makes sense or will break in any case.
- Fonts, spacing and colors, do they match the prototype, are they added in a 1 generic place for reusing.
- "Empty states" for all views which can be empty. An empty state should always be there and make clear, how to add content

## Requirements

- Task possible errors handling eg.server down, no internet connection, slow internet connection...etc

## Styling

- Code separation and organization, user pragma marks to organize the code as well as extensions eg.extension for the view controller conforming to UITableViewDataSource
- Files architecture, make sure you follow the project&#39;s files architecture
